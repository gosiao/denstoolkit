#include <cstdlib>
#include <iostream>
using std::cout;
#include <iomanip>
using std::scientific;
using std::setprecision;
#include <vector>
using std::vector;
#include "commonhelpers.h"
#include "helpersdrawer.h"
#include "povraytools.h"
#include "fileutils.h"
#include "../common/matrixvectoroperations3d.h"

bool HelpersDrawer::MakePovFile(const string &basename,const OptionFlags &options,\
      char *argv[],BondNetWork &bn) {
   string povname=basename+string(".pov");
   ofstream ofil(povname);
   if ( !ofil.good() ) {
      string msg="The file '";
      msg+=povname;
      msg+="' could not be opened!";
      ScreenUtils::DisplayErrorMessage(msg);
      ofil.close();
      return false;
   }
#if CHOOSEPOVVERSION36
   ofil << "#version 3.6; //Unless you know what you are doing, do not modify this line..." << '\n';
#endif
   ofil << "#include \"colors.inc\"" << '\n';
   FileUtils::WriteScrCharLine(ofil,'/',false);
   ofil << "//" << '\n';
#if DEBUG
   ofil << "//Code generated by HelpersDrawerNCI::MakePovFile (part of DTK)." << '\n';
#endif
   ofil << "//Below you can find some options to be parsed to povray" << '\n';
   ofil << "//set your custom values." << '\n';
   ofil << "//You can reconstruct the image using the script dtkpov2png" << '\n';
   ofil << "//" << '\n';
   FileUtils::WriteScrCharLine(ofil,'/',false);

   if (!(bn.ImStp())) {bn.SetUpBNW();}
   if (!(bn.ballAndStickMode)) {bn.drawAtSize*=AUTOMATICBALLANDSTICKRATIO;}
   bn.CalcViewRadius();

   POVRayConfiguration pvp;

   double camdist=2.5e0;
   if ( options.setzoom ) { camdist*=(std::stod(string(argv[options.setzoom]))); }
   for (int i=0; i<3; i++) {pvp.locCam[i]=0.0e0;}
   pvp.locCam[2]=1.0e0;
   double zsep=1.5e0;
   pvp.lightSource[1][0]=zsep;
   pvp.lightSource[1][1]=zsep;
   pvp.lightSource[1][2]=1.0e0;
   pvp.AddLightSource(zsep,-zsep,1.0e0);
   pvp.AddLightSource(-zsep,zsep,1.0e0);
   pvp.AddLightSource(-zsep,-zsep,1.0e0);
   pvp.AddLightSource(0.0e0,1.0e0,0.0e0);
   pvp.AddLightSource(-1.0e0,0.0e0,0.0e0);
   for (int i=1; i<pvp.nLightSources; i++) {
      for (int j=0; j<3; j++) {pvp.lightSource[i][j]*=(bn.rView*4.0e0);}
   }
   for ( size_t i=0 ; i<3 ; ++i ) { pvp.vecAngView[i]=0.0e0; }
   if ( options.rotatemol ) {
      HelpersDrawer::AlignMolecule(pvp,bn,options,argv);
      if ( options.rotX ) { pvp.vecAngView[0]=std::stod(string(argv[options.rotX])); }
      if ( options.rotY ) { pvp.vecAngView[1]=std::stod(string(argv[options.rotY])); }
      if ( options.rotZ ) { pvp.vecAngView[2]=std::stod(string(argv[options.rotZ])); }
   }
   for (int i=0; i<3; i++) {
      pvp.locCam[i]*=bn.rView*camdist;
      for (int j=0; j<2; j++) {
         pvp.lightSource[j][i]*=(bn.rView*2.0e0);
      }
   }
   ofil << "#declare GNUPlotAngle1=" << pvp.vecAngView[0] << ";" << '\n';
   ofil << "#declare GNUPlotAngle2=" << pvp.vecAngView[2] << ";" << '\n';
   ofil << "#declare YAngle=" << pvp.vecAngView[1] << ";" << '\n';
   bool tmpbool=true;
   ofil << "#declare DrawStandardBonds=" << tmpbool << ";" << '\n';
   //tmpbool=false;
   //ofil << "#declare DrawIsosurface=" << tmpbool << ";" << '\n';
   ofil << "#declare TransmitAtomSphere=0.0;" << '\n';
   ofil << "#declare TransmitStdBondCylinder=0.0;" << '\n';
   /*
   ofil << "#declare TransmitCritPts=0.0;" << '\n';
   ofil << "#declare TransmitIsosurface=" << ( options.transparentiso ? "0.4" : "0.0")
        << "; // set this between 0 (opaque) and 1 (completely transparent)." << '\n';
   // */
   ofil << "#default { finish { specular 0.2 roughness 0.03 phong .1 } }" << '\n';
   FileUtils::WriteScrCharLine(ofil,'/',false);
   ofil << "// END OF CUSTOM OPTIONS" << '\n';
   FileUtils::WriteScrCharLine(ofil ,'/',false);
   pvp.inccolors=false;
   ofil << "global_settings { ambient_light White }" << '\n';
   ofil << "\nbackground { color < 0, 0.5, 0.7 > }\n" << '\n';
   for (int i=0; i<pvp.nLightSources; i++) {
      pvp.WriteLightSource(ofil,i,0.5,"  rotate < GNUPlotAngle1, YAngle, GNUPlotAngle2 >\n");
   }
   ofil << "camera {";
   ofil << "\n  location ";
   HelpersPOVRay::WriteVector(ofil,pvp.locCam[0],pvp.locCam[1],pvp.locCam[2]);
   ofil << "\n  up ";
   HelpersPOVRay::WriteVector(ofil,pvp.vecUp[0],pvp.vecUp[1],pvp.vecUp[2]);
   ofil << '\n' << "  right ";
   HelpersPOVRay::WriteVector(ofil,pvp.vecRight[0],pvp.vecRight[1],pvp.vecRight[2]);
   if ( options.align3at ) {
      ofil << '\n' << "  direction ";
      HelpersPOVRay::WriteVector(ofil,pvp.vecDir[0],pvp.vecDir[1],pvp.vecDir[2]);
   }
   if (options.rotX||options.rotY || options.rotZ) {
      ofil << '\n' << "  look_at ";
      HelpersPOVRay::WriteVector(ofil,pvp.lookAtCam[0],pvp.lookAtCam[1],pvp.lookAtCam[2]);
      ofil << '\n' << "  rotate < GNUPlotAngle1, YAngle, GNUPlotAngle2 >";
   }
   ofil << '\n' << "}" << '\n';
   CommonHelpers::PutNuclei(ofil,bn,pvp.currIndLev,"TransmitAtomSphere",options.cpkview);
   ofil << "#if(DrawStandardBonds)" << '\n';
   CommonHelpers::PutBonds(ofil,bn,pvp.currIndLev,"TransmitStdBondCylinder");
   ofil << "#end\n//end if DrawStandardBonds" << '\n';
   ofil.close();
   if ( options.mkpng ) {
      string cmd="dtkpov2png "+povname+" 2>/dev/null";
      system(cmd.c_str());
   }
   if (options.verboseLevel && std::stoi(string(argv[options.verboseLevel]))>0) {
      cout << "Rendering done." << '\n';
   }
   return true;
}
bool HelpersDrawer::AlignMolecule(POVRayConfiguration &pvp,BondNetWork &bn,\
         const OptionFlags &options,char *argv[]) {
   if ( options.align3at ) { return AlignMolecule3Atoms(pvp,bn,options,argv); }
   return false;
}
bool HelpersDrawer::AlignMolecule3Atoms(POVRayConfiguration &pvp,BondNetWork &bn,\
         const OptionFlags &options,char *argv[]) {
   int aIdx=std::stoi(string(argv[options.align3at  ]))-1;
   int bIdx=std::stoi(string(argv[options.align3at+1]))-1;
   int cIdx=std::stoi(string(argv[options.align3at+2]))-1;
   vector<double> a(3),b(3),c(3);
   for ( size_t i=0 ; i<3 ; ++i ) { a[i]=bn.R[aIdx][i]; }
   for ( size_t i=0 ; i<3 ; ++i ) { b[i]=bn.R[bIdx][i]; }
   for ( size_t i=0 ; i<3 ; ++i ) { c[i]=bn.R[cIdx][i]; }
   vector<double> y(3);
   for ( size_t i=0 ; i<3 ; ++i ) { y[i]=a[i]-b[i]; }
   vector<double> tmp(3);
   for ( int i=0 ; i<3 ; ++i ) { tmp[i]=c[i]-b[i]; }
   vector<double> z=MatrixVectorOperations3D::CrossProduct(tmp,y);
   vector<double> x=MatrixVectorOperations3D::CrossProduct(y,z);
   MatrixVectorOperations3D::Normalize(x);
   MatrixVectorOperations3D::Normalize(y);
   MatrixVectorOperations3D::Normalize(z);
   cout << scientific << setprecision(5);
   vector<vector<double> > m1=MatrixVectorOperations3D::GetMatrixToAlignVToZ(z);
   tmp=x;
   x=MatrixVectorOperations3D::MatrixVectorProduct(m1,tmp);
   tmp=y;
   y=MatrixVectorOperations3D::MatrixVectorProduct(m1,tmp);
   tmp=z;
   z=MatrixVectorOperations3D::MatrixVectorProduct(m1,tmp);
   vector<double> yu=MatrixVectorOperations3D::Y();
   double angle=-acos(MatrixVectorOperations3D::InnerProduct(yu,y));
   vector<double> zu=MatrixVectorOperations3D::Z();
   vector<double> cross=MatrixVectorOperations3D::CrossProduct(yu,y);
   if ( MatrixVectorOperations3D::InnerProduct(cross,zu) < 0.0e0 ) { angle=-angle; }
   vector<vector<double> > m2=MatrixVectorOperations3D::GetRotationMatrixAroundZ(angle);
   tmp=MatrixVectorOperations3D::MatrixVectorProduct(m2,y);
   vector<vector<double> > M=MatrixVectorOperations3D::MatrixProduct(m2,m1);
#if 1
   MatrixVectorOperations3D::Transpose(M);

   tmp[0]=0.0e0; tmp[1]=0.0e0; tmp[2]=1.0e0;
   vector<double> vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
   pvp.locCam[0]=vpos[0]; pvp.locCam[1]=vpos[1]; pvp.locCam[2]=vpos[2];

   tmp[0]=0.0e0; tmp[1]=0.0e0; tmp[2]=-1.0e0;
   vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
   pvp.vecDir[0]=vpos[0]; pvp.vecDir[1]=vpos[1]; pvp.vecDir[2]=vpos[2];
   vector<double> vt(3);
   for ( size_t i=0 ; i<3 ; ++i ) {
      vt[i]=pvp.vecDir[i];
      tmp[i]=pvp.locCam[i];
   }
   double proj=MatrixVectorOperations3D::InnerProduct(vt,tmp);
   if ( proj>=0 ) {
      for ( size_t i=0 ; i<3 ; ++i ) { pvp.vecDir[i]=-pvp.vecDir[i]; }
   }

   tmp[0]=4.0e0/3.0e0; tmp[1]=0.0e0; tmp[2]=0.0e0;
   vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
   pvp.vecRight[0]=vpos[0]; pvp.vecRight[1]=vpos[1]; pvp.vecRight[2]=vpos[2];

   //tmp[0]=pvp.vecUp[0]; tmp[1]=pvp.vecUp[1]; tmp[2]=pvp.vecUp[2];
   tmp[0]=0.0e0; tmp[1]=1.0e0; tmp[2]=0.0e0;
   vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
   pvp.vecUp[0]=vpos[0]; pvp.vecUp[1]=vpos[1]; pvp.vecUp[2]=vpos[2];

   for ( int i=0 ; i<pvp.nLightSources ; ++i ) {
      for ( int j=0 ; j<3 ; ++j ) { tmp[j]=pvp.lightSource[i][j]; }
      vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
      for ( int j=0 ; j<3 ; ++j ) { pvp.lightSource[i][j]=vpos[j]; }
   }
#else
   tmp[0]=0.0e0; tmp[1]=0.0e0; tmp[2]=1.0e0;
   vector<double> vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
   for ( int i=0 ; i<bn.nNuc ; ++i ) {
      for ( int j=0 ; j<3 ; ++j ) { tmp[j]=bn.R[i][j]; }
      vpos=MatrixVectorOperations3D::MatrixVectorProduct(M,tmp);
      for ( int j=0 ; j<3 ; ++j ) { bn.R[i][j]=vpos[j]; }
   }
#endif
   return true;
}

